<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="{{ url_for('static', filename='CSS/Toka_fitness.css') }}">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
      body, html {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
        background: #222529;
      }
    
      canvas {
        position: fixed;
        top: 0;
        left: 0;
        z-index: 0;       
        display: block;
      }

      .Login_Box_Container,
      .login_container_alternate {
        position: relative;
        z-index: 1;      
      }
    </style>
</head>

<body>

<canvas id="bg"></canvas>

      {% if error %}
    <div style="
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 80%;
        max-width: 400px;
        background-color: #ffdddd;
        color: #b30000;
        font-size: 18px;
        border: 1px solid #b30000;
        border-radius: 8px;
        text-align: center;
        padding: 12px 20px;
        box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        z-index: 2;
    ">
        {{ error }}
    </div>
    {% endif %}


<div class="Login_Box_Container">
    <p id="myParagraph" style="font-family: 'Times New Roman', Times, serif; font-size: x-large; text-align: center; color: white;">Log in</p>


    <form method="POST" action="{{ url_for('login') }}">
        <div class="floating-group">
          <input type="text" name="username" required>
          <label for="username">Enter your Username</label>
        </div>

        <div class="floating-group">
          <input type="password" name="password" required>
          <label for="password">Enter your Password</label>
        </div>

        <p id="myParagraph" style="color: white; justify-self: center;">Forget Your password?</p>

        <button class="Login_button_style" type="submit">Log In</button>

        <p style="color: #626468;">________________________ OR _______________________</p>
    </form>
</div>








<div class="login_container_alternate">
    <button class="Login_button_alternate_style" onclick="window.location.href='{{ url_for('home') }}'">Hello</button>
    <button class="Login_button_alternate_style" onclick="window.location.href='{{ url_for('home') }}'">Hello</button>
    
    <p style="text-align: center; color: #626468; margin-top: 35px;" id="myParagraph">
        New to Toka? Sign up now.
    </p>
</div>

<div class="change_modes_container">
  <button id="modeBtn" style="
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 10px 20px;
      border-radius: 10px;
  "> 
      Mode: REPULSE
  </button>
</div>






    
</body>
  <script>
  const canvas = document.getElementById('bg');
  const ctx = canvas.getContext('2d');
  
  const paragraphs = Array.from(document.querySelectorAll("p"));
  let paragraphRects = [];

  function updateParagraphRects(){

    paragraphRects = paragraphs.map(el => el.getBoundingClientRect());
  }
  
  updateParagraphRects();




  let particleCount = 900;
  let particles = [];


  const mouse = { x: null, y: null };
  

  let mode = "repulse";
  document.getElementById("modeBtn").onclick = () => {
    mode = (mode === "repulse") ? "swirl" : "repulse";
    document.getElementById("modeBtn").textContent = "Mode: " + mode.toUpperCase();

    if (mode === "repulse") resetParticleSpeeds();
  };


  window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
  window.addEventListener('touchmove', e => {
    const t = e.touches[0];
    mouse.x = t.clientX;
    mouse.y = t.clientY;
  });
  window.addEventListener('touchend', () => { mouse.x = null; mouse.y = null; });

  
  function resizeCanvas() {

     const dpr = window.devicePixelRatio || 1;

  // Set real pixel size (important!)
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;


  canvas.style.width = window.innerWidth + "px";
  canvas.style.height = window.innerHeight + "px";


  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  updateParagraphRects();

    updateParagraphRects(); 
  }
  window.addEventListener('resize', resizeCanvas);


  window.addEventListener('scroll', updateParagraphRects, {passive: true});


  function createParticles() {
    particles = [];
    for (let i = 0; i < particleCount; i++) {
      particles.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: Math.random() * 3 + 1,
        speedX: (Math.random() - 0.5) * 2,
        speedY: (Math.random() - 0.5) * 2,
        pullFactor: 0.02 + Math.random() * 0.03, 
        swirlOffset: Math.random() * Math.PI * 2
      });
    }
  }

  
  function resetParticleSpeeds() {
    particles.forEach(p => {
      p.speedX = (Math.random() - 0.5) * 2;
      p.speedY = (Math.random() - 0.5) * 2;
    });
  }



  
  function drawParticles() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const swirlRadius = 400;       
    const particleRepulsion = 12;  

    particles.forEach((p, i) => {

      if (mouse.x !== null && mouse.y !== null) {
        let dx = mouse.x - p.x;
        let dy = mouse.y - p.y;
        let distance = Math.sqrt(dx*dx + dy*dy) || 1;

    
        if (mode === "repulse" && distance < 200) {
          let nx = -dx / distance;
          let ny = -dy / distance;
          let force = (200 - distance) / 200;
          let strength = 8;
          p.x += nx * force * strength;
          p.y += ny * force * strength;
        }

        
        if (mode === "swirl") {
          // Individual pull toward mouse
          p.x += dx * p.pullFactor;
          p.y += dy * p.pullFactor;

          
          let angle = Math.atan2(dy, dx) + p.swirlOffset;
          let swirlStrength = 1.8;
          p.x += Math.cos(angle) * swirlStrength;
          p.y += Math.sin(angle) * swirlStrength;

          
          for (let j = 0; j < particles.length; j++) {
            if (i === j) continue;
            let px = particles[j].x - p.x;
            let py = particles[j].y - p.y;
            let pd = Math.sqrt(px*px + py*py) || 1;
            if (pd < particleRepulsion) {
              let repelStrength = (particleRepulsion - pd)/particleRepulsion * 0.5;
              p.x -= (px / pd) * repelStrength;
              p.y -= (py / pd) * repelStrength;
            }
          }
        }
      }


      p.x += p.speedX;
      p.y += p.speedY;
      
      const inflate = 40;
      const maxsteer = 0.25;
      const speedlimit = 6;

      for (let r = 0; r < paragraphRects.length; r++) {
      const rect = paragraphRects[r];


      const insideX = p.x > rect.left - inflate && p.x < rect.right + inflate;
      const insideY = p.y > rect.top - inflate && p.y < rect.bottom + inflate;

      if (insideX && insideY) {
        
        const centerX = (rect.left + rect.right) / 2;
        const centerY = (rect.top + rect.bottom) / 2;

      
        const dx = p.x - centerX;
        const dy = p.y - centerY;

      
        const distanceX = Math.abs(dx);
        const maxDistX = (rect.width / 2) + inflate;
        let steerStrengthX = 1 - (distanceX / maxDistX);
        steerStrengthX = Math.max(0, Math.min(steerStrengthX, 1));
        steerStrengthX = steerStrengthX * steerStrengthX; 

        


        const distanceY = Math.abs(dy);
        const maxDistY = (rect.height / 2) + inflate;
        let pushStrengthY = 1 - (distanceY / maxDistY);
        pushStrengthY = Math.max(0, Math.min(pushStrengthY, 1));
        pushStrengthY = pushStrengthY * 0.6; 

        const dirX = dx < 0 ? -1 : 1;

        p.speedX += (dx < 0 ? -1 : 1) * maxsteer * steerStrengthX;

        
        p.speedY += (dy < 0 ? -1 : 1) * maxsteer * pushStrengthY;

        
        p.speedX *= 0.995;
        p.speedY *= 0.995;
      }
    }
      





      // Apply damping only in swirl mode
      if (mode === "swirl") {
          p.speedX *= 0.98;
          p.speedY *= 0.98;
      }

      // Wrap edges
      if (p.x > canvas.width) p.x = 0;
      if (p.x < 0) p.x = canvas.width;
      if (p.y > canvas.height) p.y = 0;
      if (p.y < 0) p.y = canvas.height;

      // Draw particle
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fillStyle = "white";
      ctx.fill();
    });

    requestAnimationFrame(drawParticles);
  }

  // Initialize
  resizeCanvas();
  createParticles();
  drawParticles();
  </script>












